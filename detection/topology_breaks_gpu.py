"""
Lambda¬≥ GPUÁâà„Éà„Éù„É≠„Ç∏„Ç´„É´Á†¥„ÇåÊ§úÂá∫„É¢„Ç∏„É•„Éº„É´
ÊßãÈÄ†„Éï„É≠„Éº„ÅÆ„Éà„Éù„É≠„Ç∏„Ç´„É´„Å™Á†¥„Çå„ÇíGPU„ÅßÈ´òÈÄüÊ§úÂá∫
CuPy RawKernel„Éô„Éº„ÇπÔºàPTX 8.4ÂØæÂøúÔºâ
"""

import numpy as np
import logging
from typing import Dict, List, Tuple, Optional

# CuPy„ÅåÂà©Áî®ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
try:
    import cupy as cp
    from cupyx.scipy.ndimage import gaussian_filter1d as gaussian_filter1d_gpu
    HAS_GPU = True
except ImportError:
    HAS_GPU = False
    cp = None
    gaussian_filter1d_gpu = None

from .phase_space_gpu import PhaseSpaceAnalyzerGPU
from ..types import ArrayType, NDArray
from ..core.gpu_utils import GPUBackend
from ..core.gpu_kernels import (
    anomaly_detection_kernel,
    compute_local_fractal_dimension_kernel,
    compute_gradient_kernel
)

# „É≠„Ç¨„ÉºË®≠ÂÆö
logger = logging.getLogger(__name__)

# ===============================
# CuPy RawKernelÂÆöÁæ©
# ===============================

LOCAL_EXTREMA_KERNEL_CODE = r'''
extern "C" __global__
void local_extrema_kernel(
    const float* data,
    float* extrema,
    const int window,
    const int n
) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (idx >= window && idx < n - window) {
        float center = data[idx];
        bool is_max = true;
        bool is_min = true;
        
        // Â±ÄÊâÄÁØÑÂõ≤„ÅßÊØîËºÉ
        for (int i = idx - window; i <= idx + window; i++) {
            if (i != idx) {
                if (data[i] >= center) {
                    is_max = false;
                }
                if (data[i] <= center) {
                    is_min = false;
                }
                
                // Êó©ÊúüÁµÇ‰∫Ü
                if (!is_max && !is_min) {
                    break;
                }
            }
        }
        
        extrema[idx] = (is_max || is_min) ? 1.0f : 0.0f;
    }
}
'''

class TopologyBreaksDetectorGPU(GPUBackend):
    """„Éà„Éù„É≠„Ç∏„Ç´„É´Á†¥„ÇåÊ§úÂá∫„ÅÆGPUÂÆüË£ÖÔºàCuPy RawKernelÁâàÔºâ"""
    
    def __init__(self, force_cpu=False):
        super().__init__(force_cpu)
        self.breaks_cache = {}
        
        # CuPy RawKernel„Çí„Ç≥„É≥„Éë„Ç§„É´
        if HAS_GPU and not force_cpu:
            try:
                self.local_extrema_kernel = cp.RawKernel(
                    LOCAL_EXTREMA_KERNEL_CODE, 'local_extrema_kernel'
                )
                logger.info("‚úÖ Topology breaks kernel compiled successfully (PTX 8.4)")
            except Exception as e:
                logger.warning(f"Failed to compile local extrema kernel: {e}")
                self.local_extrema_kernel = None
        else:
            self.local_extrema_kernel = None
        
    def detect_topological_breaks(self,
                                structures: Dict[str, np.ndarray],
                                window_steps: int) -> Dict[str, np.ndarray]:
        """
        „Éà„Éù„É≠„Ç∏„Ç´„É´Á†¥„Çå„ÅÆÊ§úÂá∫ÔºàÂÆåÂÖ®GPUÁâàÔºâ
        
        Parameters
        ----------
        structures : Dict[str, np.ndarray]
            LambdaÊßãÈÄ†ËæûÊõ∏
        window_steps : int
            „Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫
            
        Returns
        -------
        Dict[str, np.ndarray]
            ÂêÑÁ®ÆÁ†¥„Çå„ÅÆÊ§úÂá∫ÁµêÊûú
        """
        print("\nüí• Detecting topological breaks on GPU...")
        
        n_frames = len(structures['rho_T'])
        
        # temporary_allocation„Çí‰ΩøÁî®
        with self.memory_manager.temporary_allocation(n_frames * 4 * 8, "topology_breaks"):
            # 1. ŒõFÁï∞Â∏∏ÔºàÊßãÈÄ†„Éï„É≠„ÉºÁ†¥„ÇåÔºâ
            lambda_f_anomaly = self._detect_flow_anomalies_gpu(
                structures['lambda_F_mag'], window_steps
            )
            
            # 2. ŒõFFÁï∞Â∏∏ÔºàÂä†ÈÄüÂ∫¶Á†¥„ÇåÔºâ
            lambda_ff_anomaly = self._detect_acceleration_anomalies_gpu(
                structures['lambda_FF_mag'], window_steps // 2
            )
            
            # 3. „ÉÜ„É≥„Ç∑„Éß„É≥Â†¥„Ç∏„É£„É≥„Éó
            rho_t_breaks = self._detect_tension_field_jumps_gpu(
                structures['rho_T'], window_steps
            )
            
            # 4. „Éà„Éù„É≠„Ç∏„Ç´„É´„ÉÅ„É£„Éº„Ç∏Áï∞Â∏∏
            q_breaks = self._detect_topological_charge_breaks_gpu(
                structures['Q_lambda']
            )
            
            # 5. ‰ΩçÁõ∏„Ç≥„Éí„Éº„É¨„É≥„ÇπÁ†¥„ÇåÔºàÊñ∞Ë¶èËøΩÂä†Ôºâ
            phase_coherence_breaks = self._detect_phase_coherence_breaks_gpu(
                structures
            )
            
            # 6. ÊßãÈÄ†ÁöÑÁâπÁï∞ÁÇπÊ§úÂá∫ÔºàÊñ∞Ë¶èËøΩÂä†Ôºâ
            singularities = self._detect_structural_singularities_gpu(
                structures, window_steps
            )
            
            # 7. Áµ±ÂêàÁï∞Â∏∏„Çπ„Ç≥„Ç¢
            combined_anomaly = self._combine_topological_anomalies_gpu(
                lambda_f_anomaly,
                lambda_ff_anomaly,
                rho_t_breaks,
                q_breaks,
                phase_coherence_breaks,
                singularities
            )
        
        return {
            'lambda_F_anomaly': self.to_cpu(lambda_f_anomaly),
            'lambda_FF_anomaly': self.to_cpu(lambda_ff_anomaly),
            'rho_T_breaks': self.to_cpu(rho_t_breaks),
            'Q_breaks': self.to_cpu(q_breaks),
            'phase_coherence_breaks': self.to_cpu(phase_coherence_breaks),
            'singularities': self.to_cpu(singularities),
            'combined_anomaly': self.to_cpu(combined_anomaly)
        }
    
    def _detect_flow_anomalies_gpu(self,
                                 lambda_f_mag: np.ndarray,
                                 window: int) -> NDArray:
        """ÊßãÈÄ†„Éï„É≠„Éº„ÅÆÁï∞Â∏∏Ê§úÂá∫ÔºàGPUÊúÄÈÅ©ÂåñÔºâ"""
        lf_mag_gpu = self.to_gpu(lambda_f_mag)
        
        # ÈÅ©ÂøúÁöÑz-score„Å´„Çà„ÇãÁï∞Â∏∏Ê§úÂá∫Ôºà„Ç´„Éº„Éç„É´‰ΩøÁî®Ôºâ
        anomaly_gpu = anomaly_detection_kernel(lf_mag_gpu, window)
        
        # ËøΩÂä†: ÊÄ•ÊøÄ„Å™Â§âÂåñ„ÅÆÊ§úÂá∫
        if self.is_gpu:
            gradient = cp.abs(cp.gradient(lf_mag_gpu))
        else:
            gradient = np.abs(np.gradient(lambda_f_mag))
            
        sudden_changes = self._detect_sudden_changes_gpu(gradient, window)
        
        # ‰∏°Êñπ„ÅÆÁï∞Â∏∏„ÇíÁµ±Âêà
        if self.is_gpu:
            return cp.maximum(anomaly_gpu, sudden_changes)
        else:
            return np.maximum(anomaly_gpu, sudden_changes)
    
    def _detect_acceleration_anomalies_gpu(self,
                                         lambda_ff_mag: np.ndarray,
                                         window: int) -> NDArray:
        """Âä†ÈÄüÂ∫¶Áï∞Â∏∏„ÅÆÊ§úÂá∫"""
        lff_mag_gpu = self.to_gpu(lambda_ff_mag)
        
        # Âü∫Êú¨ÁöÑ„Å™Áï∞Â∏∏Ê§úÂá∫Ôºà„Ç´„Éº„Éç„É´‰ΩøÁî®Ôºâ
        anomaly_gpu = anomaly_detection_kernel(lff_mag_gpu, window)
        
        # Âä†ÈÄüÂ∫¶ÁâπÊúâ„ÅÆÂá¶ÁêÜÔºöÁ¨¶Âè∑Â§âÂåñ„ÅÆÊ§úÂá∫
        if 'lambda_FF' in self.breaks_cache:
            lambda_ff = self.to_gpu(self.breaks_cache['lambda_FF'])
            sign_changes = self._detect_sign_changes_gpu(lambda_ff)
            if self.is_gpu:
                anomaly_gpu = cp.maximum(anomaly_gpu, sign_changes)
            else:
                anomaly_gpu = np.maximum(anomaly_gpu, sign_changes)
        
        return anomaly_gpu
    

    def _detect_tension_field_jumps_gpu(self,
                                      rho_t: np.ndarray,
                                      window_steps: int) -> NDArray:
        """„ÉÜ„É≥„Ç∑„Éß„É≥Â†¥„ÅÆ„Ç∏„É£„É≥„ÉóÊ§úÂá∫ÔºàÊîπËâØÁâàÔºâ"""
        rho_t_gpu = self.to_gpu(rho_t)
        
        # „Éû„É´„ÉÅ„Çπ„Ç±„Éº„É´„Çπ„É†„Éº„Ç∏„É≥„Ç∞
        sigmas = [window_steps/6, window_steps/3, window_steps/2]
        
        if self.is_gpu:
            jumps_multiscale = cp.zeros_like(rho_t_gpu)
        else:
            jumps_multiscale = np.zeros_like(rho_t)
        
        for sigma in sigmas:
            # „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éï„Ç£„É´„Çø
            if self.is_gpu and gaussian_filter1d_gpu is not None:
                rho_t_smooth = gaussian_filter1d_gpu(rho_t_gpu, sigma=sigma)
                # „Ç∏„É£„É≥„ÉóÊ§úÂá∫
                jumps = cp.abs(rho_t_gpu - rho_t_smooth)
                # Ê≠£Ë¶èÂåñ
                jumps_norm = jumps / (cp.std(jumps) + 1e-10)
            else:
                from scipy.ndimage import gaussian_filter1d
                rho_t_np = rho_t if not self.is_gpu else cp.asnumpy(rho_t_gpu)
                rho_t_smooth = gaussian_filter1d(rho_t_np, sigma=sigma)
                jumps = np.abs(rho_t_np - rho_t_smooth)
                jumps_norm = jumps / (np.std(jumps) + 1e-10)
                if self.is_gpu:
                    jumps_norm = cp.asarray(jumps_norm)
            
            jumps_multiscale += jumps_norm / len(sigmas)
        
        return jumps_multiscale
    
    def _detect_topological_charge_breaks_gpu(self,
                                            q_lambda: np.ndarray) -> NDArray:
        """„Éà„Éù„É≠„Ç∏„Ç´„É´„ÉÅ„É£„Éº„Ç∏„ÅÆÁ†¥„ÇåÊ§úÂá∫"""
        q_lambda_gpu = self.to_gpu(q_lambda)
        
        if self.is_gpu:
            breaks = cp.zeros_like(q_lambda_gpu)
            # ‰ΩçÁõ∏Â∑Æ„ÅÆË®àÁÆó
            phase_diff = cp.abs(cp.diff(q_lambda_gpu))
            # ÈñæÂÄ§‰ª•‰∏ä„ÅÆÊÄ•ÊøÄ„Å™Â§âÂåñ„ÇíÊ§úÂá∫
            threshold = 0.1  # 0.1 * 2œÄ radians
            breaks[1:] = cp.where(phase_diff > threshold, phase_diff, 0)
        else:
            breaks = np.zeros_like(q_lambda)
            phase_diff = np.abs(np.diff(q_lambda))
            threshold = 0.1
            breaks[1:] = np.where(phase_diff > threshold, phase_diff, 0)
        
        # Á¥ØÁ©çÁöÑ„Å™Á†¥„Çå„ÅÆÊ§úÂá∫
        cumulative_breaks = self._detect_cumulative_breaks_gpu(q_lambda_gpu)
        
        if self.is_gpu:
            return cp.maximum(breaks, cumulative_breaks)
        else:
            return np.maximum(breaks, cumulative_breaks)
    
    def _detect_phase_coherence_breaks_gpu(self,
                                         structures: Dict) -> NDArray:
        """‰ΩçÁõ∏„Ç≥„Éí„Éº„É¨„É≥„Çπ„ÅÆÁ†¥„ÇåÊ§úÂá∫ÔºàÊñ∞Ê©üËÉΩÔºâ"""
        if 'structural_coherence' not in structures:
            if self.is_gpu:
                return cp.zeros(len(structures['rho_T']))
            else:
                return np.zeros(len(structures['rho_T']))
        
        coherence_gpu = self.to_gpu(structures['structural_coherence'])
        
        if self.is_gpu:
            # „Ç≥„Éí„Éº„É¨„É≥„Çπ„ÅÆÊÄ•ÊøÄ„Å™‰Ωé‰∏ã„ÇíÊ§úÂá∫
            coherence_gradient = cp.gradient(coherence_gpu)
            
            # Ë≤†„ÅÆÂãæÈÖçÔºà„Ç≥„Éí„Éº„É¨„É≥„Çπ‰Ωé‰∏ãÔºâ„ÇíÂº∑Ë™ø
            breaks = cp.where(coherence_gradient < 0,
                             -coherence_gradient * 2.0,
                             cp.abs(coherence_gradient))
            
            # ÈñæÂÄ§Âá¶ÁêÜ
            threshold = cp.mean(breaks) + 2 * cp.std(breaks)
            breaks = cp.where(breaks > threshold, breaks, 0)
        else:
            coherence_gradient = np.gradient(structures['structural_coherence'])
            breaks = np.where(coherence_gradient < 0,
                             -coherence_gradient * 2.0,
                             np.abs(coherence_gradient))
            threshold = np.mean(breaks) + 2 * np.std(breaks)
            breaks = np.where(breaks > threshold, breaks, 0)
        
        return breaks
    
    def _detect_structural_singularities_gpu(self,
                                       structures: Dict,
                                       window: int) -> NDArray:
        """ÊßãÈÄ†ÁöÑÁâπÁï∞ÁÇπ„ÅÆÊ§úÂá∫ÔºàÊñ∞Ê©üËÉΩÔºâ"""
        n_frames = len(structures['rho_T'])
        
        if self.is_gpu:
            singularities = cp.zeros(n_frames)
        else:
            singularities = np.zeros(n_frames)
        
        # Ë§áÊï∞„ÅÆÊåáÊ®ô„Åã„ÇâÁâπÁï∞ÁÇπ„ÇíÊ§úÂá∫
        rho_t_gpu = self.to_gpu(structures['rho_T'])
        lf_mag_gpu = self.to_gpu(structures['lambda_F_mag'])
        
        # 1. „ÉÜ„É≥„Ç∑„Éß„É≥Â†¥„ÅÆÂ±ÄÊâÄÊ•µÂÄ§
        tension_extrema = self._find_local_extrema_gpu(rho_t_gpu, window)
        
        # 2. „Éï„É≠„ÉºÂ†¥„ÅÆÁô∫Êï£/ÂèéÊùü
        if len(structures['lambda_F'].shape) == 2:  # „Éô„ÇØ„Éà„É´Â†¥„ÅÆÂ†¥Âêà
            lambda_f_gpu = self.to_gpu(structures['lambda_F'])
            divergence = self._compute_divergence_gpu(lambda_f_gpu)
            
            # divergence„ÅÆÈï∑„Åï„ÇíÁ¢∫Ë™ç„Åó„Å¶Ë™øÊï¥
            if len(divergence) != n_frames:
                # divergence„ÅåÁü≠„ÅÑÂ†¥Âêà„ÅØ„Éë„Éá„Ç£„É≥„Ç∞
                if len(divergence) < n_frames:
                    if self.is_gpu:
                        divergence = cp.pad(divergence, (0, n_frames - len(divergence)), mode='edge')
                    else:
                        divergence = np.pad(divergence, (0, n_frames - len(divergence)), mode='edge')
                else:
                    # divergence„ÅåÈï∑„ÅÑÂ†¥Âêà„ÅØÂàá„ÇäË©∞„ÇÅ
                    divergence = divergence[:n_frames]
            
            if self.is_gpu:
                div_anomaly = cp.abs(divergence) > cp.std(divergence) * 3
                singularities += div_anomaly.astype(cp.float32)
            else:
                div_anomaly = np.abs(divergence) > np.std(divergence) * 3
                singularities += div_anomaly.astype(np.float32)
        
        # 3. ‰ΩçÁõ∏Á©∫Èñì„Åß„ÅÆÁï∞Â∏∏ËªåÈÅì
        phase_anomaly = self._detect_phase_space_singularities_gpu(
            lf_mag_gpu, rho_t_gpu, window
        )
        
        # phase_anomaly„ÅÆÈï∑„Åï„ÇÇÁ¢∫Ë™ç
        if len(phase_anomaly) != n_frames:
            if len(phase_anomaly) < n_frames:
                if self.is_gpu:
                    phase_anomaly = cp.pad(phase_anomaly, (0, n_frames - len(phase_anomaly)), mode='edge')
                else:
                    phase_anomaly = np.pad(phase_anomaly, (0, n_frames - len(phase_anomaly)), mode='edge')
            else:
                phase_anomaly = phase_anomaly[:n_frames]
        
        # tension_extrema„ÅÆÈï∑„Åï„ÇÇÁ¢∫Ë™ç
        if len(tension_extrema) != n_frames:
            if len(tension_extrema) < n_frames:
                if self.is_gpu:
                    tension_extrema = cp.pad(tension_extrema, (0, n_frames - len(tension_extrema)), mode='edge')
                else:
                    tension_extrema = np.pad(tension_extrema, (0, n_frames - len(tension_extrema)), mode='edge')
            else:
                tension_extrema = tension_extrema[:n_frames]
        
        singularities += tension_extrema + phase_anomaly
        
        return singularities / 3.0  # Ê≠£Ë¶èÂåñ
    
    def _detect_sudden_changes_gpu(self,
                                 gradient: NDArray,
                                 window: int) -> NDArray:
        """ÊÄ•ÊøÄ„Å™Â§âÂåñ„ÅÆÊ§úÂá∫"""
        # ÁßªÂãïÊ®ôÊ∫ñÂÅèÂ∑Æ
        moving_std = self._moving_std_gpu(gradient, window)
        
        # Â§ñ„ÇåÂÄ§Ê§úÂá∫
        threshold = 3.0
        
        if self.is_gpu:
            sudden_changes = cp.where(
                gradient > moving_std * threshold,
                gradient / (moving_std + 1e-10),
                0
            )
        else:
            sudden_changes = np.where(
                gradient > moving_std * threshold,
                gradient / (moving_std + 1e-10),
                0
            )
        
        return sudden_changes
    
    def _detect_sign_changes_gpu(self, vector_field: NDArray) -> NDArray:
        """Á¨¶Âè∑Â§âÂåñ„ÅÆÊ§úÂá∫"""
        if len(vector_field.shape) == 1:
            # „Çπ„Ç´„É©„ÉºÂ†¥
            if self.is_gpu:
                sign_diff = cp.diff(cp.sign(vector_field))
                changes = cp.abs(sign_diff) / 2.0
                return cp.pad(changes, (1, 0), mode='constant')
            else:
                sign_diff = np.diff(np.sign(vector_field))
                changes = np.abs(sign_diff) / 2.0
                return np.pad(changes, (1, 0), mode='constant')
        else:
            # „Éô„ÇØ„Éà„É´Â†¥
            if self.is_gpu:
                changes = cp.zeros(len(vector_field))
            else:
                changes = np.zeros(len(vector_field))
                
            for i in range(vector_field.shape[1]):
                component = vector_field[:, i]
                if self.is_gpu:
                    sign_diff = cp.diff(cp.sign(component))
                    changes[1:] += cp.abs(sign_diff) / (2.0 * vector_field.shape[1])
                else:
                    sign_diff = np.diff(np.sign(component))
                    changes[1:] += np.abs(sign_diff) / (2.0 * vector_field.shape[1])
            return changes
    
    def _detect_cumulative_breaks_gpu(self, q_lambda: NDArray) -> NDArray:
        """Á¥ØÁ©çÁöÑ„Å™Á†¥„Çå„ÅÆÊ§úÂá∫"""
        if self.is_gpu:
            # Á¥ØÁ©çÂíå
            q_cumsum = cp.cumsum(q_lambda)
            
            # ÊúüÂæÖ„Åï„Çå„ÇãÁ∑öÂΩ¢ÊàêÈï∑„Åã„Çâ„ÅÆ‰πñÈõ¢
            x = cp.arange(len(q_lambda))
            slope = (q_cumsum[-1] - q_cumsum[0]) / (len(q_lambda) - 1)
            expected = q_cumsum[0] + slope * x
            
            deviation = cp.abs(q_cumsum - expected)
            
            # ÊÄ•ÊøÄ„Å™‰πñÈõ¢„ÇíÊ§úÂá∫
            deviation_gradient = cp.abs(cp.gradient(deviation))
            
            return deviation_gradient / (cp.max(deviation_gradient) + 1e-10)
        else:
            q_cumsum = np.cumsum(q_lambda)
            x = np.arange(len(q_lambda))
            slope = (q_cumsum[-1] - q_cumsum[0]) / (len(q_lambda) - 1)
            expected = q_cumsum[0] + slope * x
            deviation = np.abs(q_cumsum - expected)
            deviation_gradient = np.abs(np.gradient(deviation))
            return deviation_gradient / (np.max(deviation_gradient) + 1e-10)
    
    def _find_local_extrema_gpu(self,
                               data: NDArray,
                               window: int) -> NDArray:
        """Â±ÄÊâÄÊ•µÂÄ§„ÅÆÊ§úÂá∫ - CuPy RawKernel‰ΩøÁî®ÔºàPTX 8.4ÂØæÂøúÔºâ"""
        data_gpu = self.to_gpu(data).astype(cp.float32)
        
        if self.is_gpu and self.local_extrema_kernel is not None:
            extrema = cp.zeros_like(data_gpu, dtype=cp.float32)
            
            # CuPy RawKernelÂëº„Å≥Âá∫„Åó
            threads = 256
            blocks = (len(data_gpu) + threads - 1) // threads
            
            self.local_extrema_kernel(
                (blocks,), (threads,),
                (data_gpu, extrema, window, len(data_gpu))
            )
            
            cp.cuda.Stream.null.synchronize()
            return extrema
        else:
            # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºàCPU„Åæ„Åü„ÅØCuPyÔºâ
            if self.is_gpu:
                extrema = cp.zeros_like(data_gpu)
                for i in range(window, len(data_gpu) - window):
                    local_max = cp.max(data_gpu[i-window:i+window+1])
                    local_min = cp.min(data_gpu[i-window:i+window+1])
                    if data_gpu[i] == local_max or data_gpu[i] == local_min:
                        extrema[i] = 1.0
            else:
                extrema = np.zeros_like(data)
                for i in range(window, len(data) - window):
                    local_max = np.max(data[i-window:i+window+1])
                    local_min = np.min(data[i-window:i+window+1])
                    if data[i] == local_max or data[i] == local_min:
                        extrema[i] = 1.0
            return extrema
    
    def _compute_divergence_gpu(self, vector_field: NDArray) -> NDArray:
        """„Éô„ÇØ„Éà„É´Â†¥„ÅÆÁô∫Êï£„ÇíË®àÁÆóÔºà‰øÆÊ≠£ÁâàÔºâ"""
        if len(vector_field.shape) != 2:
            if self.is_gpu:
                return cp.zeros(len(vector_field))
            else:
                return np.zeros(len(vector_field))
        
        n_frames = len(vector_field)
        
        # ÂêÑÊàêÂàÜ„ÅÆÂÅèÂæÆÂàÜ
        if self.is_gpu:
            div = cp.zeros(n_frames)  # ÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫„ÅßÂàùÊúüÂåñ
            for i in range(vector_field.shape[1]):
                # gradient„ÅØÂêå„ÅòÈï∑„Åï„ÇíËøî„Åô„ÅØ„Åö
                component_grad = cp.gradient(vector_field[:, i])
                div += component_grad
        else:
            div = np.zeros(n_frames)  # ÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫„ÅßÂàùÊúüÂåñ
            for i in range(vector_field.shape[1]):
                component_grad = np.gradient(vector_field[:, i])
                div += component_grad
        
        return div
        
    def _detect_phase_space_singularities_gpu(self,
                                            lf_mag: NDArray,
                                            rho_t: NDArray,
                                            window: int) -> NDArray:
        """‰ΩçÁõ∏Á©∫Èñì„Åß„ÅÆÁâπÁï∞ÁÇπÊ§úÂá∫"""
        n = len(lf_mag)
        
        if self.is_gpu:
            singularities = cp.zeros(n)
        else:
            singularities = np.zeros(n)
        
        # Á∞°ÊòìÁöÑ„Å™‰ΩçÁõ∏Á©∫ÈñìÂüã„ÇÅËæº„Åø
        for i in range(window, n - window):
            # Â±ÄÊâÄÁöÑ„Å™ËªåÈÅì„ÅÆÁï∞Â∏∏ÊÄß
            local_lf = lf_mag[i-window:i+window]
            local_rho = rho_t[i-window:i+window]
            
            # Áõ∏Èñ¢„ÅÆÊÄ•ÊøÄ„Å™Â§âÂåñ
            if len(local_lf) > 5:
                if self.is_gpu:
                    corr = cp.corrcoef(local_lf, local_rho)[0, 1]
                    if cp.isnan(corr):
                        corr = 0
                    # Áõ∏Èñ¢„ÅÆÁµ∂ÂØæÂÄ§„Åå‰Ωé„ÅÑ = ÁâπÁï∞ÁöÑ
                    singularities[i] = 1 - cp.abs(corr)
                else:
                    corr = np.corrcoef(local_lf, local_rho)[0, 1]
                    if np.isnan(corr):
                        corr = 0
                    singularities[i] = 1 - np.abs(corr)
        
        return singularities
    
    def _moving_std_gpu(self, data: NDArray, window: int) -> NDArray:
        """ÁßªÂãïÊ®ôÊ∫ñÂÅèÂ∑Æ„ÅÆË®àÁÆó"""
        if self.is_gpu:
            std_array = cp.zeros_like(data)
        else:
            std_array = np.zeros_like(data)
        
        for i in range(len(data)):
            start = max(0, i - window // 2)
            end = min(len(data), i + window // 2 + 1)

            if end - start > 1:
                if self.is_gpu:
                    local_data = data[start:end]
                    # NaN„ÉÅ„Çß„ÉÉ„ÇØ
                    if cp.any(cp.isnan(local_data)):
                        std_array[i] = 0.0
                    else:
                        std_array[i] = cp.std(local_data)
                else:
                    local_data = data[start:end]
                    if np.any(np.isnan(local_data)):
                        std_array[i] = 0.0
                    else:
                        std_array[i] = np.std(local_data)
        
        return std_array
    
    def _combine_topological_anomalies_gpu(self, *anomalies) -> NDArray:
        """„Éà„Éù„É≠„Ç∏„Ç´„É´Áï∞Â∏∏„ÅÆÁµ±Âêà"""
        # ÂÖ®„Å¶„ÅÆÈï∑„Åï„ÇíÊèÉ„Åà„Çã
        min_len = min(len(a) for a in anomalies)
        
        # Èáç„ÅøÔºàÊñ∞„Åó„ÅÑÁ†¥„Çå„Çø„Ç§„Éó„ÇÇÂê´„ÇÄÔºâ
        weights = [1.0, 0.8, 0.6, 1.2, 0.9, 1.1]
        
        if self.is_gpu:
            combined = cp.zeros(min_len)
        else:
            combined = np.zeros(min_len)
        
        for i, (anomaly, weight) in enumerate(zip(anomalies, weights)):
            if i < len(weights):
                combined += weight * anomaly[:min_len]
        
        combined /= sum(weights[:len(anomalies)])
        
        return combined


# ===============================
# „ÉÜ„Çπ„ÉàÈñ¢Êï∞
# ===============================

def test_topology_breaks():
    """„Éà„Éù„É≠„Ç∏„Ç´„É´Á†¥„ÇåÊ§úÂá∫„ÅÆ„ÉÜ„Çπ„Éà"""
    print("\nüß™ Testing Topology Breaks Detection GPU...")
    
    # „ÉÜ„Çπ„Éà„Éá„Éº„ÇøÁîüÊàê
    n_frames = 10000
    structures = {
        'rho_T': np.random.randn(n_frames).astype(np.float32),
        'lambda_F': np.random.randn(n_frames, 3).astype(np.float32),  # „Éô„ÇØ„Éà„É´Â†¥
        'lambda_F_mag': np.random.rand(n_frames).astype(np.float32),
        'lambda_FF_mag': np.random.rand(n_frames).astype(np.float32),
        'Q_lambda': np.cumsum(np.random.randn(n_frames) * 0.1).astype(np.float32),
        'structural_coherence': np.random.rand(n_frames).astype(np.float32)
    }
    
    # Ê§úÂá∫Âô®ÂàùÊúüÂåñ
    detector = TopologyBreaksDetectorGPU()
    
    # „Éà„Éù„É≠„Ç∏„Ç´„É´Á†¥„ÇåÊ§úÂá∫ÂÆüË°å
    print("Running topological breaks detection...")
    results = detector.detect_topological_breaks(structures, window_steps=100)
    
    # ÁµêÊûúÁ¢∫Ë™ç
    for key, value in results.items():
        print(f"  {key}: shape={value.shape}, mean={np.mean(value):.4f}, max={np.max(value):.4f}")
    
    # Â±ÄÊâÄÊ•µÂÄ§Ê§úÂá∫„ÅÆ„ÉÜ„Çπ„Éà
    print("\nTesting local extrema detection...")
    test_data = np.sin(np.linspace(0, 4*np.pi, 1000)).astype(np.float32)
    extrema = detector._find_local_extrema_gpu(test_data, window=10)
    n_extrema = np.sum(detector.to_cpu(extrema) > 0)
    print(f"  Found {n_extrema} extrema in sine wave")
    
    print("\n‚úÖ Topology breaks detection test passed!")
    return True

if __name__ == "__main__":
    test_topology_breaks()
